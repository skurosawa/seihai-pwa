diff --git a/src/App.tsx b/src/App.tsx
index 15f1544f40d72c40fce0182c95780ca3fbb753c1..879910a083a33d29e22ef4906c29bb60ad2b5807 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -1,53 +1,81 @@
 import React, { useEffect, useMemo, useRef, useState } from "react";
 import { generateAction } from "./model/thought";
 
 import {
   DndContext,
+  type DragEndEvent,
   PointerSensor,
   TouchSensor,
   closestCenter,
   useSensor,
   useSensors,
 } from "@dnd-kit/core";
 import {
   SortableContext,
   arrayMove,
   useSortable,
   verticalListSortingStrategy,
 } from "@dnd-kit/sortable";
 import { CSS } from "@dnd-kit/utilities";
 
 // const LEGACY_STORAGE_KEY = "seihai_v1_rawText";
 const STORAGE_KEY = "seihai_v2_state";
 const SAVE_DEBOUNCE_MS = 300;
 
 type ThoughtItem = { id: string; text: string };
 
 function makeId() {
-  // @ts-ignore
-  return (crypto?.randomUUID?.() ?? `id_${Date.now()}_${Math.random()}`).toString();
+  const randomId = globalThis.crypto?.randomUUID?.();
+  return (randomId ?? `id_${Date.now()}_${Math.random()}`).toString();
+}
+
+function loadInitialState(): { draft: string; items: ThoughtItem[] } {
+  if (typeof window === "undefined") return { draft: "", items: [] };
+
+  try {
+    const saved = window.localStorage.getItem(STORAGE_KEY);
+    if (!saved) return { draft: "", items: [] };
+
+    const parsed = JSON.parse(saved) as Partial<{ draft: unknown; items: unknown }>;
+    const draft = typeof parsed.draft === "string" ? parsed.draft : "";
+    const items = Array.isArray(parsed.items)
+      ? parsed.items.filter(
+          (item): item is ThoughtItem =>
+            typeof item === "object" &&
+            item !== null &&
+            "id" in item &&
+            "text" in item &&
+            typeof item.id === "string" &&
+            typeof item.text === "string"
+        )
+      : [];
+
+    return { draft, items };
+  } catch {
+    return { draft: "", items: [] };
+  }
 }
 
 /* =========================
    Swipe Row
    ========================= */
 function SwipeRow({ text, onDelete }: { text: string; onDelete: () => void }) {
   const startX = useRef<number | null>(null);
   const [dx, setDx] = useState(0);
   const [dragging, setDragging] = useState(false);
 
   const clamp = (v: number, min: number, max: number) =>
     Math.min(max, Math.max(min, v));
 
   const onPointerDown = (e: React.PointerEvent) => {
     if (e.pointerType === "mouse" && e.button !== 0) return;
     (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
     startX.current = e.clientX;
     setDragging(true);
   };
 
   const onPointerMove = (e: React.PointerEvent) => {
     if (!dragging || startX.current == null) return;
     const delta = e.clientX - startX.current;
     setDx(clamp(delta, -120, 0));
   };
@@ -119,117 +147,104 @@ function SortableItem({
       }}
     >
       <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
         <span
           {...attributes}
           {...listeners}
           style={{
             padding: "10px",
             borderRadius: 10,
             background: "white",
             cursor: "grab",
             fontWeight: 800,
           }}
         >
           ☰
         </span>
         <div style={{ flex: 1 }}>
           <SwipeRow text={item.text} onDelete={onDelete} />
         </div>
       </div>
     </div>
   );
 }
 
 export default function App() {
-  const [draft, setDraft] = useState("");
-  const [items, setItems] = useState<ThoughtItem[]>([]);
+  const [initialState] = useState(loadInitialState);
+  const [draft, setDraft] = useState(initialState.draft);
+  const [items, setItems] = useState<ThoughtItem[]>(initialState.items);
   const [undo, setUndo] = useState<{ item: ThoughtItem; index: number } | null>(null);
 
   // 追加：上部セグメントの現在位置（スワイプ追従）
   const [activeIndex, setActiveIndex] = useState(0);
 
   const undoTimerRef = useRef<number | null>(null);
   const textareaRef = useRef<HTMLTextAreaElement | null>(null);
   const pagerRef = useRef<HTMLDivElement | null>(null);
 
   const goToPage = (index: number) => {
     const el = pagerRef.current;
     if (!el) return;
     el.scrollTo({ left: el.clientWidth * index, behavior: "smooth" });
   };
 
-  /* =========================
-     初期化
-     ========================= */
-  useEffect(() => {
-    try {
-      const saved = localStorage.getItem(STORAGE_KEY);
-      if (saved) {
-        const parsed = JSON.parse(saved);
-        setDraft(parsed.draft ?? "");
-        setItems(parsed.items ?? []);
-      }
-    } catch {}
-  }, []);
-
   useEffect(() => {
     const id = setTimeout(() => {
       localStorage.setItem(STORAGE_KEY, JSON.stringify({ draft, items }));
     }, SAVE_DEBOUNCE_MS);
 
     return () => clearTimeout(id);
   }, [draft, items]);
 
   useEffect(() => {
     const el = textareaRef.current;
     if (!el) return;
     el.style.height = "auto";
     el.style.height = Math.min(el.scrollHeight, 4 * 24) + "px";
   }, [draft]);
 
   useEffect(() => {
     return () => {
       if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
     };
   }, []);
 
   // 追加：スワイプでページが動いたらセグメントを追従
   useEffect(() => {
     const el = pagerRef.current;
     if (!el) return;
 
     const onScroll = () => {
       const w = el.clientWidth || 1;
       const idx = Math.round(el.scrollLeft / w);
       const clamped = Math.max(0, Math.min(2, idx));
       setActiveIndex(clamped);
     };
 
     el.addEventListener("scroll", onScroll, { passive: true });
     onScroll();
-    return () => el.removeEventListener("scroll", onScroll as any);
+    return () => el.removeEventListener("scroll", onScroll);
   }, []);
 
   const thoughts = useMemo(() => items.map((x) => x.text), [items]);
   const action = useMemo(() => generateAction(thoughts), [thoughts]);
 
   /* =========================
      操作
      ========================= */
 
   const showUndo = (payload: { item: ThoughtItem; index: number }) => {
     setUndo(payload);
     if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
     undoTimerRef.current = window.setTimeout(() => setUndo(null), 5000);
   };
 
   const undoDelete = () => {
     if (!undo) return;
     const { item, index } = undo;
 
     setItems((prev) => {
       const next = [...prev];
       next.splice(Math.min(index, next.length), 0, item);
       return next;
     });
 
@@ -251,66 +266,68 @@ export default function App() {
     setDraft("");
     requestAnimationFrame(() => goToPage(1));
   };
 
   const clearDraft = () => setDraft("");
 
   const resetAll = () => {
     if (!confirm("入力とリストをすべて消します。取り消し不可。続けるにゃ？")) return;
 
     setDraft("");
     setItems([]);
     localStorage.removeItem(STORAGE_KEY);
   };
 
   const onShare = async () => {
     const text = [
       action ? `## 行動\n${action}\n` : "",
       thoughts.length ? `## 整理\n${thoughts.map((t) => `- ${t}`).join("\n")}` : "",
     ].join("\n");
 
     try {
       if (navigator.share) {
         await navigator.share({ title: "Seihai", text });
         return;
       }
-    } catch {}
+    } catch {
+      // Fallback to clipboard share below.
+    }
 
     await navigator.clipboard.writeText(text);
     alert("コピーしたにゃ");
   };
 
   const sensors = useSensors(
     useSensor(TouchSensor, {
       activationConstraint: { delay: 120, tolerance: 6 },
     }),
     useSensor(PointerSensor, {
       activationConstraint: { distance: 6 },
     })
   );
 
-  const onDragEnd = (event: any) => {
+  const onDragEnd = (event: DragEndEvent) => {
     const { active, over } = event;
     if (!over || active.id === over.id) return;
 
     const oldIndex = items.findIndex((x) => x.id === active.id);
     const newIndex = items.findIndex((x) => x.id === over.id);
 
     setItems(arrayMove(items, oldIndex, newIndex));
   };
 
   return (
     <>
       {/* ======= iOS風 上部ナビ（セグメント） ======= */}
       <header className="topnav">
         <div className="topnav__title">Seihai</div>
 
         <div className="seg" role="tablist" aria-label="Seihai steps">
           {(["入力", "整理", "行動"] as const).map((label, i) => (
             <button
               key={label}
               type="button"
               role="tab"
               aria-selected={activeIndex === i}
               className={`seg__btn ${activeIndex === i ? "is-active" : ""}`}
               onClick={() => goToPage(i)}
             >
